/*
 * Device tree for GIHMM GSP V001 - FPGA-UART
 */

/dts-v1/;
#include <dt-bindings/input/input.h>
#include <dt-bindings/interrupt-controller/irq.h>
/* i.MX6 UltraLite CPU */
#include "imx6ul.dtsi"
/* ConnectCore 6UL (wireless/bluetooth variant) */
#include "imx6ul-ccimx6ul-wb.dtsi"

/ {
	// Add here your platform model.
	model = "GIHMM - GSP V001 - ConnectCore 6UL SOM";
	// Add here your compatible platform.
	compatible = "gihmm,gsp-ctrl", "gihmm,cc-wmx-mod", "digi,ccimx6ul", "fsl,imx6ul";

	reg_usb_otg1_vbus: reg_usb_otg1@0 {
		compatible = "regulator-fixed";
		regulator-name = "usb_otg1_vbus";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		gpio = <&gpio1 4 GPIO_ACTIVE_HIGH>;
		enable-active-high;
	};

	reg_i2c1_bme280_vddd: reg_i2c1_bme280_1 {
		compatible = "regulator-fixed";
		regulator-name = "vddd";
		regulator-min-microvolt = <3300000>;
      	regulator-max-microvolt = <3300000>;
      	regulator-always-on;
	};

	reg_i2c1_bme280_vdda: reg_i2c1_bme280_2 {
		compatible = "regulator-fixed";
		regulator-name = "vdda";
		regulator-min-microvolt = <3300000>;
      	regulator-max-microvolt = <3300000>;
      	regulator-always-on;
	};
};

&ecspi1 {
	num-cs = <1>;
	pinctrl-names = "default";
	status = "okay";

	/*
	 * Configure the GPIO that you selected as 'slave select'.
	 */
	cs-gpios = <&gpio3 26 GPIO_ACTIVE_LOW>;

	/*
	 * ECSPI1 (as master)
	 */
	pinctrl-0 = <&pinctrl_ecspi1>;

	/*
	 * Reference block.
	 *
	 * Add your slave devices here. Next is an example of spidev.
	 * Expect a harmless kernel warning if you enable spidev as slave.
	 */
	//spidev@0 {
	//	reg = <0>;
	//	compatible = "spidev";
	//	spi-max-frequency = <1000000>;
	//	status = "okay";
	//};

	digipot0: pot@0{
		reg = <0>;
		spi-max-frequency = <1000000>;
		compatible = "microchip,mcp41100", "spidev";
		status = "okay";
	};

};

&i2c1 {

	humidity_sensor: hdc1080@40{
		compatible = "ti,hdc1080";
		reg = <0x40>;
		status = "okay";
	};

	pressure_sensor: BME280@76{
		compatible = "bosch,bme280";
		reg = <0x76>;
		vddd-supply = <&reg_i2c1_bme280_vddd>;
        vdda-supply = <&reg_i2c1_bme280_vdda>;
		status = "okay";
	};

	//Missing Device Driver for TCN75
	temperature_sensor: TCN75@49{
		compatible = "microchip,tcn75";
		reg = <0x49>;
		status = "okay";
	};
};

&fec1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet0>, <&pinctrl_enet_mdio>;
	phy-mode = "rmii";
	phy-handle = <&ethphy0>;

	/*
	 * Optional fields.
	 *
	 * Configure the PHY reset with a GPIO in your design.
	 */
	phy-reset-gpios = <&gpio5 6 GPIO_ACTIVE_LOW>;
	phy-reset-duration = <26>;
	digi,phy-reset-in-suspend;

	status = "okay";
	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@0 {
			compatible = "ethernet-phy-ieee802.3-c22";

			/*
			 * Add your custom PHY configuration.
			 */
			smsc,disable-energy-detect;
			reg = <0>;
		};

		//ethphy2: ethernet-phy@1 {
		//	compatible = "ethernet-phy-ieee802.3-c22";

			/*
			 * Add your custom PHY configuration.
			 */
			//smsc,disable-energy-detect;
		//	reg = <1>;
		//};
	};
};

&mca_adc {
	digi,adc-ch-list = <3 4 5>;

	/*
	 * ADC reference voltage. Use:
	 *   - digi,adc-vref: Value in uV that corresponds with the VCC_MCA voltage.
	 *   - digi,internal-vref: If present, the internal 1.2 V reference is used.
	 *     This forces MCA_IO2/EXT_VREF to be configured as a 1.2 V output, and a
	 *     100 nF capacitor must be placed between this line and GND.
	 *     If this property is set, the value in 'digi,adc-vref' is ignored.
	 */
	digi,adc-vref = <3300000>;
	//digi,internal-vref;
};

&adc1 {
    pinctrl-names = "default";
    adc-ch-list = <5>;
    status = "okay";
};

&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart2>;

	//uart-has-rtscts;

	status = "okay";
};

&uart3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart3>;

	status = "okay";
};

&uart5 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_console>;
	status = "okay";
};

&uart6 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart6>;

	status = "okay";
};

&usbotg1 {
	dr_mode = "otg";

	/* Set the proper voltage regulator. */
	vbus-supply = <&reg_usb_otg1_vbus>;

	/*
	 * Configure the power line if needed.
	 */
	digi,power-line-active-high;

	/*
	 * Configure the overcurrent line if needed.
	 */
	//disable-over-current;

	pinctrl-0 = <&pinctrl_usbotg1>;

	status = "okay";
};

&usdhc2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc2>;
	broken-cd;      /* no carrier detect line (use polling) */
	no-1-8-v;
	status = "okay";
};

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hog>;

	imx6ul-ccimx6ul {
		pinctrl_console: uart5grp {
			fsl,pins = <
				MX6UL_PAD_UART5_RX_DATA__UART5_DCE_RX		0x1b0b1
				MX6UL_PAD_UART5_TX_DATA__UART5_DCE_TX		0x1b0b1
			>;
		};

		pinctrl_ecspi1: ecspi1grp1 {
			fsl,pins = <
				MX6UL_PAD_LCD_DATA22__ECSPI1_MOSI		0x10b0
				MX6UL_PAD_LCD_DATA23__ECSPI1_MISO		0x10b0
				MX6UL_PAD_LCD_DATA20__ECSPI1_SCLK		0x10b0
			>;
		};

		pinctrl_enet0: enet1grp {
			fsl,pins = <
				MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00		0x1b0b0
				MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01		0x1b0b0
				MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00		0x1b0b0
				MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01		0x1b0b0
				MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN		0x1b0b0
				MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1		0x4001b031
				MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN		0x1b0b0
				MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER		0x1b0b0
			>;
		};

		pinctrl_enet_mdio: mdioenetgrp {
			fsl,pins = <
				MX6UL_PAD_GPIO1_IO07__ENET1_MDC		0x1b0b0
				MX6UL_PAD_GPIO1_IO06__ENET1_MDIO		0x1b0b0
			>;
		};

		pinctrl_hog: hoggrp {
			fsl,pins = <
				/* ENET 0_INT# */
				MX6UL_PAD_GPIO1_IO08__GPIO1_IO08		0x10b0
				/* SPI 0 - CS */
				MX6UL_PAD_LCD_DATA21__GPIO3_IO26		0x10b0
				/* ENET_Pwr */
				MX6UL_PAD_LCD_HSYNC__GPIO3_IO02		0x10b0
				/* ReedSwitch */
				MX6UL_PAD_LCD_VSYNC__GPIO3_IO03		0x10b0
				/* HVon */
				MX6UL_PAD_LCD_DATA08__GPIO3_IO13		0x10b0
				/* inhibit */
				MX6UL_PAD_LCD_DATA09__GPIO3_IO14		0x10b0
				/* Addr0 */
				MX6UL_PAD_LCD_DATA15__GPIO3_IO20		0x10b0
				/* Addr1 */
				MX6UL_PAD_LCD_DATA16__GPIO3_IO21		0x10b0
				/* Addr2 */
				MX6UL_PAD_LCD_DATA17__GPIO3_IO22		0x10b0
				/* Comm422 */
				MX6UL_PAD_LCD_DATA18__GPIO3_IO23		0x10b0
				/* Comm485 */
				MX6UL_PAD_LCD_DATA19__GPIO3_IO24		0x10b0
				/* RS_Select */
				MX6UL_PAD_GPIO1_IO09__GPIO1_IO09		0x10b0
				/* 422_EN_485 */
				MX6UL_PAD_UART3_CTS_B__GPIO1_IO26		0x10b0
				/* 422_EN */
				MX6UL_PAD_UART3_RTS_B__GPIO1_IO27		0x10b0
				/* Spare2 */
				MX6UL_PAD_CSI_DATA05__GPIO4_IO26		0x10b0
				/* Spare3 */
				MX6UL_PAD_CSI_DATA04__GPIO4_IO25		0x10b0
				/* Spare4 */
				MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01		0x10b0
				/* Spare5 */
				MX6UL_PAD_SNVS_TAMPER5__GPIO5_IO05		0x10b0
			>;
		};

		pinctrl_uart2: uart2grp {
			fsl,pins = <
				MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX		0x1b0b1
				MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX		0x1b0b1
				MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS		0x1b0b1
				MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS		0x1b0b1
			>;
		};

		pinctrl_uart3: uart3grp {
			fsl,pins = <
				MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX		0x1b0b1
				MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX		0x1b0b1
			>;
		};

		pinctrl_uart6: uart6grp {
			fsl,pins = <
				MX6UL_PAD_CSI_PIXCLK__UART6_DCE_RX		0x1b0b1
				MX6UL_PAD_CSI_MCLK__UART6_DCE_TX		0x1b0b1
			>;
		};

		pinctrl_usbotg1: usbotg1grp {
			fsl,pins = <
				MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID		0x17059
				MX6UL_PAD_GPIO1_IO01__USB_OTG1_OC		0x17059
				MX6UL_PAD_GPIO1_IO04__USB_OTG1_PWR		0x17059
			>;
		};

		pinctrl_usdhc2: usdhc2grp {
			fsl,pins = <
				MX6UL_PAD_CSI_VSYNC__USDHC2_CLK		0x10039
				MX6UL_PAD_CSI_HSYNC__USDHC2_CMD		0x17059
				MX6UL_PAD_CSI_DATA00__USDHC2_DATA0		0x17059
				MX6UL_PAD_CSI_DATA01__USDHC2_DATA1		0x17059
				MX6UL_PAD_CSI_DATA02__USDHC2_DATA2		0x17059
				MX6UL_PAD_CSI_DATA03__USDHC2_DATA3		0x17059
			>;
		};
	};
};
